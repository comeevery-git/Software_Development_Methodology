#### 2부. 모델 주도 설계의 기본 요소

### 6장. 도메인 객체의 생명주기
> 모든 객체에는 생명주기가 있다.
> 
> 객체는 생성되어 다양한 상태를 거친 후 결국 저장되거나 삭제되면서 소멸한다.
> 
> 이 장에서는 도메인 객체의 생명주기를 관리하는 데 필요한 기본적인 개념을 살펴본다.


---


[//]: # (- 한 객체는 생성되어 다양한 상태를 거친 후 결국 저장되거나 삭제되면서 소멸한다.)

[//]: # (  - 물론 이들 중 상당수는 객체의 생성자를 호출해서 만들어진 다음 특정 연산에서 사용된 후 가비지 컬렉터에게 보내지는 단순하고 일시적인&#40;transient&#41; 객체다.)

[//]: # (  - 이런 객체는 복잡하게 만들 필요가 없다.)

[//]: # (- 다른 객체들은 더 오래 지속되며, 활성 메모리 안에서만 시간을 보내지는 않는다.)

[//]: # (  - 그것들은 다른 객체와 복잡한 상호의존성을 맺는다.)

[//]: # (    - 또한 여러가지 상태의 변화를 겪기도 하는데, 이때 갖가지 불변식이 적용된다.)

[//]: # (    - 이러한 객체들을 관리하는 데 실패한다면 MODEL-DRIVEN DESIGN을 시도하는 것이 쉽게 좌절될 수 있다.)

도메인 객체의 관리와 관련된 문제는 아래의 두 가지 범주로 나뉜다.
1. 생명주기 동안의 무결성 유지하기
2. 생명주기 관리의 복잡성으로 모델이 난해해지는 것을 방지하기

먼저, `AGGREGATE(집합체)`는 소유권과 경계를 명확히 정의함으로써 모델을 엄격하게 만들어 객체 간의 연관관계가 혼란스럽게 얽히지 않게 한다.
- 이 패턴은 생명주기상의 전 단계에 걸쳐 도메인 객체의 무결성을 유지하는 데 매우 중요하다.

다음으로 생명주기의 초기 단계로, `FACTORY(팩터리)`를 이용해 복잡한 객체와 AGGREGATE 를
생성하고 재구성함으로써 그것들의 내부 구조를 캡슐화하는 것에 관해 살펴본다.

마지막으로, 생명주기의 중간과 마지막을 다루며 거대한 관련 인프라스트럭처를 캡슐화하면서 영속 객체를 찾아 조회하는 수단을 제공하는 `REPOSITORY(리파지터리)`를 살펴보겠다.
- 비록 REPOSITORY와 FACTORY가 도메인에서 나오는 것은 아니지만 그것들은 도메인 설계에서 중요한 역할을 담당한다.
  - 이러한 구성물은 모델 객체에 쉽게 접근하는 수단을 제공해 MODEL-DRIVEN DESIGN을 완성한다.

- AGGREGATE를 모델링하고 설계에 FACTORY와 REPOSITORY를 추가하면 모델 객체의 생명주기 동안 그것들을 체계적이고 의미있는 단위로 조작할 수 있다.
  - AGGREGATE는 생명주기의 전 단계에서 불변식이 유지돼야 할 범위를 표시해준다.
  - 그리고 FACTORY와 REPOSITORY는 AGGREGATE를 대상으로 연산을 수행하며 특정 생명주기로 옮겨가는 데 따르는 복잡성을 캡슐화한다.

> AGGREGATE는 모델의 일부로서의 객체를 그룹화하고,
> 
> FACTORY는 AGGREGATE를 생성하고,
> 
> REPOSITORY는 AGGREGATE를 저장하고 조회한다.


---


### AGGREGATE(집합체)
- 모델 내에서 복잡한 연관관계를 맺는 객체를 대상으로 변경의 일관성을 보장하기란 쉽지 않다.
  - 그 까닭은 단지 개별 객체만이 아닌 서로 밀접한 관계에 있는 객체 집합에도 불변식이 적용돼야 하기 때문이다.
  - 그렇다고 변경의 일관성을 보장하고자 신중 잠금 기법(cautious locking technique, 예를들어 데이터베이스 락)을 쓴다면 다수의 사용자가 서로 부적절하게 간섭해서 시스템이 사용할 수 없는 상태가 될 것이다.
- 문제의 근원은 모델에 경계가 정의돼 있지 않다는 데 있다.
  - 모델을 근간으로 하는 해법을 이용하면 모델을 좀더 이해하기 쉬워지고 설계한 바가 더 쉽게 전달될 것이다.
  - 모델이 개선됨에 따라 해당 모델이 구현을 어떻게 바꿔야 할지 안내할 것이다.

- 모델 내의 소유 관계를 정의하는 갖가지 방법들이 있다.
  - 단순하지만 엄격한 체계는 그와 같은 개념에서 정수를 뽑아낸 것으로서, 객체와 해당 객체의 소유자를 변경하는 트랜잭션을 구현하기 위한 각종 규칙을 포함한다.

``먼저 우리는 모델 내의 참조에 대한 캡슐화를 추상화할 필요가 있다.``
- 각 AGGREGATE에는 루트(root)와 경계(boundary)가 있다.
  - AGGREGATE는 우리가 데이터 변경의 단위로 다루는 연관 객체의 묶음을 말한다.
  - 경계는 AGGREGATE에 무엇이 포함되고 포함되지 않는 지를 정의한다.
  - 루트는 단 하나만 존재하며, AGGREGATE에 포함된 특정 ENTITY를 가리킨다.
    - 경계안의 객체는 서로 참조할 수 있지만, 경계 바깥의 객체는 해당 AGGREGATE의 구성요소 가운데 루트만 참조할 수 있다.
    - 루트 이외의 ENTITY는 지역 식별성(local identity)를 지니며, 지역 식별성은 AGGREGATE 내에서만 구분되면 된다.
      - 이는 해당 AGGREGATE의 경계 밖에 위치한 객체는 루트 ENTITY의 컨텍스트 말고는 AGGREGATE의 내부를 볼 수 없기 때문이다.

- 불변식은 데이터가 변경될 때마다 유지돼야 하는 일관성 규칙을 뜻하며, 여기엔 AGGREGATE를 구성하는 각 구성요소 간의 관계도 포함될 것이다.
  - 그러나 AGGREGATE에 걸쳐 존재하는 규칙이 언제나 최신 상태로 유지되는 것은 아니다.
  - 다른 의존 관계는 이벤트 처리, 배치 처리, 혹은 다른 갱신 메커니즘을 토대로 특정 시간 내에 해결될 수 있다.
  - 반면, 한 AGGREGATE에 적용된 불변식은 각 트랜잭션이 완료될 때 이행될 것이다.

`이제 그러한 개념적 AGGREGATE를 구현하려면 모든 트랜잭션에 적용되는 다음과 같은 규칙이 필요하다.`
- 루트 ENTITY는 전역 식별성을 지니며 궁극적으로 불변식을 검사할 책임이 있다.
- 각 루트 ENTITY는 전역 식별성을 지닌다. 경계 안의 ENTITY는 지역 식별성을 지니며, 이러한 지역 식별성은 해당 AGGREGATE 안에서만 유일하다.
- AGGREGATE의 경계 밖에서는 루트 ENTITY를 제외한 AGGREGATE 내부의 구성요소를 참조할 수 없다.
  - 루트 ENTITY가 내부 ENTITY에 대한 참조를 다른 객체에 전달해줄 수는 있다.
    - 그러한 객체는 전달받은 참조를 일시적으로만 사용할 수 있고, 참조를 계속 보유하고 있을 수는 없다.
  - 루트는 VALUDE OBJECT의 복사본을 다른 객체에 전달해 줄 수 있으며, 복사본에서는 어떤 일이 일어나든 문제되지 않는다.
    - 이것은 복사본이 단순한 VALUE에 불과하며 AGGREGATE와는 더는 연관관계를 맺지 않을 것이기 때문이다.
- 지금까지의 규칙을 바탕으로 결론을 내려보면, 데이터베이스 질의를 이용하면 AGGREGATE의 루트만 직접적으로 획득할 수 있다.
  - 루트를 통해 경계 안의 객체를 얻을 수 있지만, 경계 밖의 객체는 얻을 수 없다.
    - 다른 객체는 모두 AGGREGATE를 탐색해서 발견해야 한다.
- AGGREGATE 안의 객체는 다른 AGGREGATE의 루트만 참조할 수 있다.
- 삭제 연산은 AGGREGATE 경계 안의 모든 요소를 한 번에 제거해야 한다.
  - 가비지 컬렉션을 이용하면 이렇게 하기가 쉬운데, 루트를 제외한 나머지 구성요소는 외부에서 그것을 참조하지 않을 경우 루트가 삭제되면 가비지 컬렉터가 자동으로 그것들을 모두 수집할 것이기 때문이다.
- AGGREGATE 경계 안의 어떤 객체를 변경하더라도 전체 AGGREGATE의 불변식은 모두 지켜져야 한다.

`ENTITY와 VALUE OBJECT를 AGGREGATE로 모으고 각각에 대해 경계를 정의하라.`
- 한 ENTITY를 골라 AGGREGATE의 루트로 만들고 AGGREGATE 경계 내부의 객체에 대해서는 루트를 거쳐 접근할 수 있게하라.
- AGGREGATE 밖의 객체는 루트만 참조할 수 있게하라.
- 내부 구성요소에 대한 일시적인 참조는 단일 연산에서만 사용할 목적에 한해 외부로 전달될 수 있다.
- 루트를 경유하지 않고는 AGGREGATE의 내부를 변경할 수 없다.
- 이런 식으로 AGGREGATE의 각 요소를 배치하면 AGGREGATE 안의 객체와 전체로서의 AAGREGATE의 상태를 변경할 때 모든 불변식을 효과적으로 이행할 수 있다.
- 


---


### FACTORY(팩터리)
- 어떤 객체나 전체 AGGREGATE를 생성하는 일이 복잡해지거나 내부 구조를 너무 많이 드러내는 경우 FACTORY가 캡슐화를 제공해준다.
- 어떤 객체를 생성하는 것이 그 자체로도 주요한 연산이 될 수 있지만, 복잡한 조립 연산은 생성된 객체의 책임으로 어울리지 않는다.
  - 이런 책임을 클라이언트에 두면 이해하기 힘든 볼품없는 설계가 만들어질 수 있다.
  - 클라이언트에서 직접 필요로 하는 객체를 생성하면 클라이언트 설계가 지저분해지고 조립되는 객체나 AGGREGATE의 캡슐화를 위반하며, 클라이언트와 생성된 객체의 구현이 지나치게 결합된다.
- 일반적으로 객체의 생성과 조립은 도메인에서는 아무런 의미가 없지만 구현 측면에서는 반드시 필요하다.
  - 모델 내의 어떤 것에도 해당하지 않는 요소를 설계에 추가해야하지만, 그럼에도 그러한 요소는 도메인 계층에서 맡고있는 책임의 일부를 구성하는 것이다.
    - 자신의 책임이 다른 객체를 생성하는 것 인 프로그램 요소를 FACTORY 라 한다.

`복잡한 객체와 AGGREGATE의 인스턴스를 생성하는 책임을 별도의 객체로 옮겨라.`
- 이 객체 자체는 도메인 모델에서 아무런 책임도 맡지 않을 수 있지만, 여전히 도메인 설계의 일부를 구성한다.
- 모든 복잡한 객체 조립 과정을 캡슐화하는 동시에 클라이언트가 인스턴스화되는 객체의 구상 클래스를 참조할 필요가 없는 인터페이스를 제공하라.
- 전체 AGGREGATE를 하나의 단위로 생성해서 그것의 불변식이 이행되게 하라.

`FACTORY를 잘 설계하기 위한 방법`
- FACTORY를 설게하는 방법으로 FACTORY METHOD(팩터리 메소드), ABSTRACT FACTORY(추상 팩터리), BUILDER(빌더)와 같은 몇 가지 특수한 목적의 생성 패턴이 있지만
  - 여기서는 가장 어려운 객체 생성 문제와 관련된 패턴을 다룬다.
  - FACTORY 설계에 깊숙하게 파고드는 것이 아니라, 도메인 설계의 중요한 한 가지 구성요소로서 FACTORY가 차지하는 부분을 보여주는 데 초점을 맞춰보자.
1. 각 생성 방법은 원자적(atomic)이어야 하며, 생성된 객체나 AGGREGATE의 불변식을 모두 지켜야 한다.
   - ENTITY의 경우 전체 AGGREGATE를 생성하는 것을 의미한다.
     - 이때 모든 불변식을 충족하고 선택적인 요소도 추가될 것이다.
   - 불변적인 VALUE OBJECT의 경우 모든 속성이 올바른 최종 상태로 초기화된다는 것을 의미한다.
     - 인터페이스를 통해 올바르게 생성할 수 없는 객체를 요청할 수 있다면 예외가 발생하거나 해야한다.
2. FACTORY는 생성된 클래스보다는 생성하고자 하는 타입으로 추상화돼야 한다.


..
